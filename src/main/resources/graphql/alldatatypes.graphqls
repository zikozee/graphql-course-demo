type Sample {
    id: ID! # use uuid
    name: String!
    age: Int
    height: Float
    isTall: Boolean


    ## othe java datatypes
    dateOfBirth: Date!
    salary: Long
    money: BigDecimal
    noOfPencils: NonNegativeInt
    currency: Currency
    createdOn: DateTime

}

interface Animal{
    legs: Int!
    hasFeather: Boolean!
    color: Color!
}

type Dog implements Animal {
    legs: Int!,
    hasFeather: Boolean!
    color: Color!
    isBark: Boolean
}

type Duck implements Animal {
    legs: Int!
    hasFeather: Boolean!
    color: Color!
    isQuack: Boolean!
    wiggleButt: Boolean!
}

type Lion implements Animal {
    legs: Int!
    hasFeather: Boolean!
    color: Color!
    roar: RoarIntensity!
}

enum Color {
  BROWN, TAN, DARK_BROWN, AMBER
}

enum RoarIntensity {
    LOUD, MODERATE, LITTLE
}

# a type that return two or more types
union DogDuck = Dog | Duck | Lion


type Address {
    street: String!,
    city: String!,
    country: String!,
    zipCode: Int!
}

input AddressInput {
    street: String!,
    city: String!,
    country: String!,
    zipCode: Int!
}

# input types
input SampleInput {
    name: String!
    age: Int
    height: Float
    dateOfBirth: Date!
    salary: Long
    money: BigDecimal
    noOfPencils: NonNegativeInt
    currency: Currency
    address: [AddressInput!] # Address input is mandatory but not it could be one or more
}

input FetchSampleInput {
    id: ID! # use uuid
    name: String!
}


type Query {
    fetchSample(fetchSampleInput: FetchSampleInput): [Sample!]
    getSample(sampleInput: SampleInput): [Sample!]
}

type Mutation {
    createSample(sampleInput: SampleInput): [Sample!]
}



